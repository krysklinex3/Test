<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .state-image {
            cursor: pointer;
        }
        .clickable {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h2>Background Investigations by State</h2>
    <div id="visualization"></div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Your data structure
        const data = {
            name: "Background Investigations",
            children: [
                { 
                    name: "Alabama",
                    imageURL: "https://images.vexels.com/media/users/3/328917/isolated/preview/ed7b9116121ea96c3e13f2aa0b25e93a-alabama-retro-stroke-usa-states.png",
                    children: [
                        { 
                            name: "Countywide", 
                            value: 50,
                            children: [
                                { 
                                    name: "Mobile County", 
                                    value: 50,
                                    children: [
                                        { 
                                            name: "City of Mobile Municipal Court (Traffic/Criminal)",
                                            value: 50,
                                            url: "https://www.municipalrecordsearch.com/mobileal/Cases",
                                        }
                                    ]
                                },
                                { 
                                    name: "Montgomery County", 
                                    value: 50,
                                    children: [
                                        { 
                                            name: "City of Montgomery Municipal Court (Traffic/Criminal)",
                                            value: 50,
                                            url: "https://www.municipalrecordsearch.com/mobileal/Cases",
                                        }
                                    ]
                                }
                            ]  
                        },
                        { name: "Statewide", value: 50 },
                        { name: "Professional & Business", value: 50 },
                        { name: "Motor Vehicle Records", value: 50 }
                    ]
                },
                { 
                    name: "Hawaii",
                    imageURL: "https://images.vexels.com/media/users/3/328921/isolated/preview/dfbaa632d010fc64bedc2b0f1bc3c3d4-hawaii-retro-stroke-usa-states.png",
                    children: [
                        { name: "Countywide", value: 50 },
                        { name: "Statewide", value: 50 },
                        { name: "Professional & Business", value: 50 },
                        { name: "Motor Vehicle Records", value: 50 }
                    ]
                }
            ]
        };

        const width = window.innerWidth;
        const height = window.innerHeight;

        const root = d3.hierarchy(data)
            .sum(d => d.value || 0)
            .sort((a, b) => b.value - a.value);

        const myColors = ["#151515", "#2A2A2A", "#3F3F3F", "#545454", "#6A6A6A"];
        const color = d3.scaleOrdinal()
            .domain(d3.range(root.height + 1))
            .range(myColors);     
        
        const packLayout = d3.pack()
            .size([width, height])
            .padding(3);

        packLayout(root);

        root.descendants().forEach(d => {
            if (d.parent && d.parent.children && d.parent.children.length === 1) {
                d.r = d.r * 0.25;
            }
        });

        let focus = root;
        let view;

        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .style("font-family", "franklin-gothic")
            .style("background", "#000000")
            .attr("viewBox", `0 0 ${width} ${height}`);

        const focusLabel = d3.select("body").append("div")
            .attr("id", "focus-label")
            .style("position", "absolute")
            .style("top", "10px")
            .style("left", "10px")
            .style("color", "white")
            .text(root.data.name);

        const bubblesLayer = svg.append("g");
        const labelLayer = svg.append("g");

        // Function to wrap text within a circle
        function wrapText(text, radius, fontSize) {
            // First check if text contains manual line breaks (|)
            if (text.includes('|')) {
                const manualLines = text.split('|').map(line => line.trim());
                
                // Create temporary text element to measure text width
                const tempText = svg.append("text")
                    .style("font-size", fontSize + "px")
                    .style("font-family", "Century Gothic, sans-serif")
                    .style("visibility", "hidden");
                
                const maxWidth = radius * 1.6;
                let finalFontSize = fontSize;
                
                // Check if any line is too wide and adjust font size if needed
                let needsResize = false;
                for (let line of manualLines) {
                    tempText.text(line);
                    if (tempText.node().getComputedTextLength() > maxWidth) {
                        needsResize = true;
                        break;
                    }
                }
                
                if (needsResize) {
                    finalFontSize = Math.max(10, fontSize * 0.9);
                    tempText.remove();
                    if (finalFontSize < fontSize) {
                        return wrapText(text, radius, finalFontSize);
                    }
                }
                
                tempText.remove();
                return { lines: manualLines, fontSize: finalFontSize };
            }
            
            // Original automatic wrapping logic
            const words = text.split(/\s+/);
            const lines = [];
            let line = [];
            
            // Create temporary text element to measure text width
            const tempText = svg.append("text")
                .style("font-size", fontSize + "px")
                .style("font-family", "Century Gothic, sans-serif")
                .style("visibility", "hidden");
            
            const maxWidth = radius * 1.6; // Use diameter with some padding
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line.concat(words[i]);
                tempText.text(testLine.join(" "));
                const testWidth = tempText.node().getComputedTextLength();
                
                if (testWidth > maxWidth && line.length > 0) {
                    lines.push(line.join(" "));
                    line = [words[i]];
                } else {
                    line.push(words[i]);
                }
            }
            
            if (line.length > 0) {
                lines.push(line.join(" "));
            }
            
            tempText.remove();
            
            // If text still doesn't fit, reduce font size
            const lineHeight = fontSize * 1.2;
            const totalHeight = lines.length * lineHeight;
            
            if (totalHeight > radius * 1.8) {
                const newFontSize = Math.max(10, fontSize * 0.9);
                if (newFontSize < fontSize) {
                    return wrapText(text, radius, newFontSize);
                }
            }
            
            return { lines, fontSize };
        }

        const node = bubblesLayer.selectAll("g")
            .data(root.descendants())
            .join("g")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("click", function(event, d) {
                    if (d.data.url) {
                        window.open(d.data.url, '_blank');
                        event.stopPropagation();
                    } else if (focus !== d) {
                        zoom(d);
                        event.stopPropagation();
                    }
                });

        node.append("circle")
            .attr("r", d => d.r)
            .attr("fill", d => color(d.depth))
            .attr("stroke", "#555")
            .attr("stroke-width", 1);

        node.each(function(d) {
            d3.select(this).selectAll("a").remove();
            d3.select(this).selectAll("text.node-label").remove();
            d.labelNode = this;
        });

        const nodeLabels = labelLayer.selectAll("g.node-label-group")
            .data(root.descendants())
            .join("g")
                .attr("class", "node-label-group")
                .attr("transform", d => `translate(${d.x},${d.y})`);

        nodeLabels.each(function(d) {  
            const baseFontSize = d.children ? 50 : 20;
            const wrappedText = wrapText(d.data.name, d.r, baseFontSize);
            
            if (!d.children && d.data.url) {
                const link = d3.select(this)
                    .append("a")
                    .attr("xlink:href", d.data.url)
                    .attr("target", "_blank");
                
                const textGroup = link.append("g")
                    .attr("class", "node-label")
                    .style("cursor", "pointer");
                
                wrappedText.lines.forEach((line, i) => {
                    textGroup.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", `${(i - (wrappedText.lines.length - 1) / 2) * wrappedText.fontSize * 1.2}px`)
                        .style("font-size", wrappedText.fontSize + "px")
                        .style("font-family", "Century Gothic, sans-serif")
                        .style("fill", "lightblue")
                        .text(line);
                });
            } else {
                const textGroup = d3.select(this)
                    .append("g")
                    .attr("class", "node-label");
                
                wrappedText.lines.forEach((line, i) => {
                    textGroup.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", `${(i - (wrappedText.lines.length - 1) / 2) * wrappedText.fontSize * 1.2}px`)
                        .style("font-size", wrappedText.fontSize + "px")
                        .style("font-family", "Century Gothic, sans-serif")
                        .style("fill", "white")
                        .text(line);
                });
            }
        });

        svg.on("click", () => zoom(root));

        function zoom(d) {
            focus = d;
            d3.select("#focus-label").text(focus.data.name);
            const transition = svg.transition()
                .duration(750)
                .tween("zoom", () => {
                    const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
                    return t => zoomTo(i(t));
                });
        }

        function zoomTo(v) {
            view = v;
            const k = width / v[2];

            node.attr("transform", d =>
                `translate(${(d.x - v[0]) * k + width / 2},${(d.y - v[1]) * k + height / 2})`
            );
            node.selectAll("circle").attr("r", d => d.r * k);

            nodeLabels.attr("transform", d =>
                `translate(${(d.x - v[0]) * k + width / 2},${(d.y - v[1]) * k + height / 2})`
            );
           
            nodeLabels.selectAll(".node-label")
                .style("display", d => {
                    if (focus === root) {
                        return d.parent === root ? "inline" : "none";
                    } else {
                        return d.parent === focus ? "inline" : "none";
                    }
                });

            // Scale font sizes based on zoom level
            nodeLabels.selectAll(".node-label text")
                .style("font-size", function(d) {
                    const isChild = d.parent === focus;
                    const isLeaf = !d.children;
                    
                    if (isChild) {
                        // For focused children, use a reasonable fixed size
                        return isLeaf ? "16px" : "24px";
                    } else {
                        // For non-focused nodes, scale down significantly
                        const baseSize = isLeaf ? 16 : 24;
                        return Math.max(8, baseSize * k * 0.3) + "px";
                    }
                });

            labelLayer.selectAll("text.overlay-label").remove();
            
            if (focus === root) {
                const imgWidth = 100;
                const imgHeight = 100;
                
                const childImages = labelLayer.selectAll(".child-image")
                    .data(root.children, d => d.data.name);

                childImages.enter()
                    .append("image")
                    .attr("class", "child-image")
                    .attr("xlink:href", d => d.data.imageURL)
                    .attr("width", imgWidth)
                    .attr("height", imgHeight)
                    .attr("x", d => (d.x - v[0]) * k + width / 2 - imgWidth / 2)
                    .attr("y", d => (d.y - v[1]) * k + height / 2 - imgHeight / 2);

                childImages
                    .attr("x", d => (d.x - v[0]) * k + width / 2 - (imgWidth * k) / 2)
                    .attr("y", d => (d.y - v[1]) * k + height / 2 - (imgHeight * k) / 2)
                    .attr("width", imgWidth * k)
                    .attr("height", imgHeight * k);

                childImages.exit().remove();
            } else {
                labelLayer.selectAll(".child-image").remove();
            }
        }  
        
        zoomTo([root.x, root.y, root.r * 2]);

        document.getElementById("visualization").appendChild(svg.node());

    </script>
</body>
</html>
